<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å¯¾ç§°æ€§ - ã‚²ãƒ¼ãƒ 070</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
        }

        .game-container {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(20px);
            border-radius: 20px;
            padding: 30px;
            max-width: 800px;
            width: 90%;
            text-align: center;
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.3);
            max-height: 85vh;
            overflow-y: auto;
            overflow-x: hidden;
        }

        .game-title {
            font-size: 3rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .game-description {
            font-size: 1.2rem;
            margin-bottom: 30px;
            opacity: 0.9;
        }

        .game-stats {
            display: flex;
            justify-content: space-around;
            margin-bottom: 30px;
            flex-wrap: wrap;
            gap: 15px;
        }

        .stat {
            background: rgba(255, 255, 255, 0.2);
            padding: 15px 25px;
            border-radius: 15px;
            min-width: 100px;
        }

        .stat-label {
            font-size: 0.9rem;
            opacity: 0.8;
        }

        .stat-value {
            font-size: 1.8rem;
            font-weight: bold;
        }

        .game-area {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 40px;
            margin-bottom: 30px;
            min-height: 400px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .symmetry-area {
            display: flex;
            flex-direction: column;
            gap: 20px;
            width: 100%;
        }

        .symmetry-viewport {
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 15px;
            text-align: center;
        }

        .symmetry-viewport h4 {
            color: #ffc107;
            margin-bottom: 15px;
        }

        .symmetry-controls {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 15px;
        }

        .symmetry-controls h4 {
            color: #ffc107;
            margin-bottom: 10px;
            text-align: center;
        }

        .axis-controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
            gap: 10px;
            margin-top: 10px;
        }

        .axis-btn {
            background: rgba(255, 255, 255, 0.3);
            border: 2px solid rgba(255, 255, 255, 0.5);
            color: white;
            padding: 10px 12px;
            border-radius: 10px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
            font-size: 0.8rem;
            text-align: center;
        }

        .axis-btn:hover {
            background: rgba(255, 255, 255, 0.4);
            transform: translateY(-2px);
        }

        .axis-btn.active {
            background: rgba(255, 193, 7, 0.7);
            border-color: #ffc107;
        }

        .symmetry-info {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
        }

        .info-panels {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 10px;
            text-align: center;
        }

        .info-panel {
            background: rgba(255, 255, 255, 0.2);
            padding: 10px;
            border-radius: 8px;
            font-size: 0.9rem;
        }

        .drawing-tools {
            background: rgba(255, 255, 255, 0.1);
            padding: 10px;
            border-radius: 10px;
            margin-top: 15px;
        }

        .drawing-tools h5 {
            color: #ffc107;
            margin-bottom: 8px;
            font-size: 0.9rem;
        }

        .tool-buttons {
            display: flex;
            gap: 8px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .tool-btn {
            background: rgba(255, 255, 255, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.5);
            color: white;
            padding: 6px 12px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.8rem;
            transition: all 0.3s ease;
        }

        .tool-btn:hover {
            background: rgba(255, 255, 255, 0.4);
        }

        .tool-btn.active {
            background: rgba(76, 175, 80, 0.7);
            border-color: #4caf50;
        }

        .controls {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .btn {
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid white;
            color: white;
            padding: 12px 24px;
            border-radius: 25px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
            font-size: 1rem;
        }

        .btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-2px);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .back-btn {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .back-btn:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        .instructions {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            text-align: left;
            flex-shrink: 0;
        }

        .instructions h4 {
            color: #ffc107;
            margin-bottom: 10px;
        }

        .instructions ul {
            margin-left: 20px;
        }

        .instructions li {
            margin: 5px 0;
        }

        .progress-bar {
            width: 100%;
            height: 20px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            margin: 15px 0;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4caf50, #8bc34a);
            transition: width 0.3s ease;
            border-radius: 10px;
        }

        @media (max-width: 768px) {
            .axis-controls {
                grid-template-columns: repeat(3, 1fr);
            }
            .info-panels {
                grid-template-columns: repeat(2, 1fr);
            }
        }
    </style>
</head>
<body>
    <button class="back-btn" onclick="goBack()">â† ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã«æˆ»ã‚‹</button>

    <div class="game-container">
        <h1 class="game-title">âš–ï¸ å¯¾ç§°æ€§</h1>
        <p class="game-description">å›³å½¢ã®å¯¾ç§°æ€§ç†è§£ã¨å¯¾ç§°è»¸ç™ºè¦‹ã«ã‚ˆã‚‹å¹¾ä½•å­¦çš„ç¾çš„æ„Ÿè¦šã‚²ãƒ¼ãƒ </p>

        <div class="game-stats">
            <div class="stat">
                <div class="stat-label">å›³å½¢æ•°</div>
                <div class="stat-value" id="currentShape">1</div>
            </div>
            <div class="stat">
                <div class="stat-label">ç™ºè¦‹æ•°</div>
                <div class="stat-value" id="discoveredCount">0</div>
            </div>
            <div class="stat">
                <div class="stat-label">ç™ºè¦‹ç‡</div>
                <div class="stat-value" id="discoveryRate">0%</div>
            </div>
            <div class="stat">
                <div class="stat-label">ã‚¹ã‚³ã‚¢</div>
                <div class="stat-value" id="score">0</div>
            </div>
        </div>

        <div class="progress-bar">
            <div class="progress-fill" id="progressFill"></div>
        </div>

        <div class="instructions">
            <h4>ğŸ“‹ è©³ç´°ãƒ«ãƒ¼ãƒ«ãƒ»éŠã³æ–¹</h4>
            <ul>
                <li><strong>ç›®çš„:</strong> 20ç¨®é¡ã®å›³å½¢ã®å¯¾ç§°æ€§ã‚’åˆ†æã—ã€å¯¾ç§°è»¸ãƒ»å¯¾ç§°ä¸­å¿ƒã‚’ç™ºè¦‹ã™ã‚‹</li>
                <li><strong>ã‚²ãƒ¼ãƒ ã®æµã‚Œ:</strong>
                    <ul>
                        <li>æ§˜ã€…ãªå›³å½¢ã®å¯¾ç§°æ€§ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’è¦³å¯Ÿã™ã‚‹</li>
                        <li>å¯¾ç§°è»¸ï¼ˆç·šå¯¾ç§°ï¼‰ãƒ»å¯¾ç§°ä¸­å¿ƒï¼ˆç‚¹å¯¾ç§°ï¼‰ã‚’ç‰¹å®šã™ã‚‹</li>
                        <li>ä¸å®Œå…¨ãªå›³å½¢ã‚’å¯¾ç§°æ€§ã«åŸºã¥ã„ã¦å®Œæˆã•ã›ã‚‹</li>
                    </ul>
                </li>
                <li><strong>å¯¾ç§°è»¸æ“ä½œ:</strong> ç¸¦è»¸ãƒ»æ¨ªè»¸ãƒ»æ–œã‚è»¸ãªã©8ç¨®é¡ã®å¯¾ç§°è»¸ãƒœã‚¿ãƒ³</li>
                <li><strong>å‹åˆ©æ¡ä»¶:</strong> 20å›³å½¢ä¸­ã€ç™ºè¦‹ç‡85%ä»¥ä¸Šï¼ˆ17å›³å½¢ä»¥ä¸Šç™ºè¦‹ï¼‰ã§ã‚¯ãƒªã‚¢</li>
                <li><strong>è©•ä¾¡ã‚·ã‚¹ãƒ†ãƒ :</strong> æ­£ç¢ºãªç™ºè¦‹: +100ç‚¹ã€éƒ¨åˆ†ç™ºè¦‹: +50ç‚¹ã€èª¤ç™ºè¦‹: -25ç‚¹</li>
                <li><strong>ãƒ—ãƒ¬ã‚¤ã®ã‚³ãƒ„:</strong> å›³å½¢ã®ç¾ã—ã•ã¨è¦å‰‡æ€§ã«æ³¨ç›®ã—ã€å¯¾ç§°æ€§ã®æ³•å‰‡ã‚’ç†è§£ã™ã‚‹</li>
            </ul>
        </div>

        <div class="game-area">
            <div class="symmetry-area" id="symmetryArea">
                <div class="symmetry-viewport">
                    <h4>ğŸ¯ å›³å½¢å¯¾ç§°æ€§åˆ†æ</h4>
                    <canvas id="symmetryCanvas" width="600" height="400" style="border: 2px solid #fff; border-radius: 10px; background: rgba(255,255,255,0.9);"></canvas>
                </div>
                
                <div class="symmetry-controls">
                    <h4>ğŸ“ å¯¾ç§°è»¸ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«</h4>
                    <div class="axis-controls" id="axisControls">
                        <button class="axis-btn" onclick="findSymmetryAxis('vertical')">ç¸¦è»¸</button>
                        <button class="axis-btn" onclick="findSymmetryAxis('horizontal')">æ¨ªè»¸</button>
                        <button class="axis-btn" onclick="findSymmetryAxis('diagonal1')">æ–œã‚è»¸/</button>
                        <button class="axis-btn" onclick="findSymmetryAxis('diagonal2')">æ–œã‚è»¸\\</button>
                        <button class="axis-btn" onclick="findSymmetryAxis('center')">ç‚¹å¯¾ç§°</button>
                        <button class="axis-btn" onclick="findSymmetryAxis('rotational')">å›è»¢å¯¾ç§°</button>
                        <button class="axis-btn" onclick="findSymmetryAxis('multiple')">è¤‡æ•°è»¸</button>
                        <button class="axis-btn" onclick="findSymmetryAxis('none')">å¯¾ç§°ãªã—</button>
                    </div>
                    
                    <div class="drawing-tools">
                        <h5>âœï¸ æç”»ãƒ„ãƒ¼ãƒ«</h5>
                        <div class="tool-buttons">
                            <button class="tool-btn" onclick="setDrawingTool('complete')">å›³å½¢å®Œæˆ</button>
                            <button class="tool-btn" onclick="setDrawingTool('axis')">è»¸è¡¨ç¤º</button>
                            <button class="tool-btn" onclick="setDrawingTool('erase')">æ¶ˆå»</button>
                            <button class="tool-btn" onclick="setDrawingTool('hint')">ãƒ’ãƒ³ãƒˆ</button>
                        </div>
                    </div>
                </div>
                
                <div class="symmetry-info">
                    <div class="info-panels">
                        <div class="info-panel">
                            <strong>å›³å½¢ã‚¿ã‚¤ãƒ—:</strong><br>
                            <span id="shapeType">å¤šè§’å½¢</span>
                        </div>
                        <div class="info-panel">
                            <strong>å¯¾ç§°è»¸æ•°:</strong><br>
                            <span id="axisCount">ï¼Ÿ</span>
                        </div>
                        <div class="info-panel">
                            <strong>å¯¾ç§°ç¨®é¡:</strong><br>
                            <span id="symmetryType">åˆ†æä¸­</span>
                        </div>
                        <div class="info-panel">
                            <strong>ç™ºè¦‹çŠ¶æ³:</strong><br>
                            <span id="discoveryStatus">æœªç™ºè¦‹</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="controls">
            <button class="btn" onclick="newSymmetryChallenge()">æ–°ã—ã„å›³å½¢</button>
            <button class="btn" onclick="checkSymmetryDiscovery()">ç™ºè¦‹ãƒã‚§ãƒƒã‚¯</button>
            <button class="btn" onclick="showSymmetryGuide()">å¯¾ç§°æ€§ã‚¬ã‚¤ãƒ‰</button>
            <button class="btn" onclick="resetSymmetry()">ãƒªã‚»ãƒƒãƒˆ</button>
        </div>
    </div>

    <script>
        let gameState = {
            currentShape: 1,
            totalShapes: 20,
            discoveredCount: 0,
            score: 0,
            currentFigure: null,
            discoveredAxes: [],
            canvas: null,
            ctx: null,
            axisTypes: ['vertical', 'horizontal', 'diagonal1', 'diagonal2', 'center', 'rotational', 'multiple', 'none']
        };

        const symmetryFigures = [
            { name: 'æ­£æ–¹å½¢', type: 'square', axes: ['vertical', 'horizontal', 'diagonal1', 'diagonal2'], complexity: 'easy' },
            { name: 'æ­£ä¸‰è§’å½¢', type: 'triangle', axes: ['vertical'], complexity: 'easy' },
            { name: 'å††', type: 'circle', axes: ['multiple'], complexity: 'easy' },
            { name: 'é•·æ–¹å½¢', type: 'rectangle', axes: ['vertical', 'horizontal'], complexity: 'normal' },
            { name: 'æ­£å…­è§’å½¢', type: 'hexagon', axes: ['vertical', 'horizontal', 'diagonal1'], complexity: 'normal' },
            { name: 'ã²ã—å½¢', type: 'diamond', axes: ['vertical', 'horizontal'], complexity: 'normal' },
            { name: 'æ­£äº”è§’å½¢', type: 'pentagon', axes: ['vertical'], complexity: 'hard' },
            { name: 'æ˜Ÿå½¢', type: 'star', axes: ['multiple'], complexity: 'hard' },
            { name: 'æ¥•å††', type: 'ellipse', axes: ['vertical', 'horizontal'], complexity: 'normal' },
            { name: 'å°å½¢', type: 'trapezoid', axes: ['vertical'], complexity: 'normal' },
            { name: 'ãƒãƒ¼ãƒˆ', type: 'heart', axes: ['vertical'], complexity: 'expert' },
            { name: 'ä¸è¦å‰‡å›³å½¢', type: 'irregular', axes: ['none'], complexity: 'expert' }
        ];

        function initializeGame() {
            gameState.canvas = document.getElementById('symmetryCanvas');
            gameState.ctx = gameState.canvas.getContext('2d');
            
            resetGameState();
            generateNewFigure();
            updateDisplay();
            drawSymmetryFigure();
        }

        function resetGameState() {
            gameState = {
                currentShape: 1,
                totalShapes: 20,
                discoveredCount: 0,
                score: 0,
                currentFigure: null,
                discoveredAxes: [],
                canvas: gameState.canvas,
                ctx: gameState.ctx,
                axisTypes: ['vertical', 'horizontal', 'diagonal1', 'diagonal2', 'center', 'rotational', 'multiple', 'none']
            };
        }

        function generateNewFigure() {
            if (gameState.currentShape > gameState.totalShapes) {
                endGame();
                return;
            }
            
            const figureIndex = (gameState.currentShape - 1) % symmetryFigures.length;
            gameState.currentFigure = symmetryFigures[figureIndex];
            gameState.discoveredAxes = [];
            
            // ãƒœã‚¿ãƒ³ã®çŠ¶æ…‹ã‚’ãƒªã‚»ãƒƒãƒˆ
            document.querySelectorAll('.axis-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            
            updateFigureDisplay();
            drawSymmetryFigure();
        }

        function findSymmetryAxis(axisType) {
            // æ—¢ã«ç™ºè¦‹æ¸ˆã¿ã‹ãƒã‚§ãƒƒã‚¯
            if (gameState.discoveredAxes.includes(axisType)) {
                return;
            }
            
            // ãƒœã‚¿ãƒ³ã®çŠ¶æ…‹ã‚’æ›´æ–°
            document.querySelectorAll('.axis-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
            
            // æ­£è§£ã‹ãƒã‚§ãƒƒã‚¯
            const isCorrect = gameState.currentFigure.axes.includes(axisType);
            
            if (isCorrect) {
                gameState.discoveredAxes.push(axisType);
                gameState.score += 100;
                
                // å¯¾ç§°è»¸ã‚’æç”»
                drawSymmetryAxis(axisType);
                
                // å…¨è»¸ç™ºè¦‹ãƒã‚§ãƒƒã‚¯
                if (gameState.discoveredAxes.length >= gameState.currentFigure.axes.length) {
                    setTimeout(() => {
                        checkSymmetryDiscovery();
                    }, 1000);
                }
            } else {
                gameState.score = Math.max(0, gameState.score - 25);
                // é–“é•ã„ã®ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯
                showIncorrectFeedback();
            }
            
            updateFigureDisplay();
            updateDisplay();
        }

        function setDrawingTool(tool) {
            // ãƒ„ãƒ¼ãƒ«ãƒœã‚¿ãƒ³ã®çŠ¶æ…‹ã‚’æ›´æ–°
            document.querySelectorAll('.tool-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
            
            switch(tool) {
                case 'complete':
                    completeSymmetricFigure();
                    break;
                case 'axis':
                    showAllAxes();
                    break;
                case 'erase':
                    clearDrawing();
                    break;
                case 'hint':
                    showSymmetryHint();
                    break;
            }
        }

        function updateFigureDisplay() {
            document.getElementById('shapeType').textContent = gameState.currentFigure.name;
            document.getElementById('axisCount').textContent = gameState.currentFigure.axes.length;
            
            const symmetryTypes = {
                'vertical': 'ç·šå¯¾ç§°(ç¸¦)',
                'horizontal': 'ç·šå¯¾ç§°(æ¨ª)',
                'diagonal1': 'ç·šå¯¾ç§°(æ–œã‚)',
                'diagonal2': 'ç·šå¯¾ç§°(æ–œã‚)',
                'center': 'ç‚¹å¯¾ç§°',
                'rotational': 'å›è»¢å¯¾ç§°',
                'multiple': 'å¤šé‡å¯¾ç§°',
                'none': 'éå¯¾ç§°'
            };
            
            if (gameState.discoveredAxes.length > 0) {
                const types = gameState.discoveredAxes.map(axis => symmetryTypes[axis]).join(', ');
                document.getElementById('symmetryType').textContent = types;
            } else {
                document.getElementById('symmetryType').textContent = 'åˆ†æä¸­';
            }
            
            const discoveryStatus = `${gameState.discoveredAxes.length}/${gameState.currentFigure.axes.length} ç™ºè¦‹`;
            document.getElementById('discoveryStatus').textContent = discoveryStatus;
        }

        function drawSymmetryFigure() {
            gameState.ctx.clearRect(0, 0, gameState.canvas.width, gameState.canvas.height);
            
            // ç™½èƒŒæ™¯
            gameState.ctx.fillStyle = '#f8f9fa';
            gameState.ctx.fillRect(0, 0, gameState.canvas.width, gameState.canvas.height);
            
            const centerX = gameState.canvas.width / 2;
            const centerY = gameState.canvas.height / 2;
            const size = 120;
            
            // ã‚°ãƒªãƒƒãƒ‰è¡¨ç¤º
            drawGrid(centerX, centerY);
            
            // å›³å½¢ã®æç”»
            gameState.ctx.fillStyle = '#2196f3';
            gameState.ctx.strokeStyle = '#1976d2';
            gameState.ctx.lineWidth = 3;
            
            switch (gameState.currentFigure.type) {
                case 'square':
                    drawSquare(centerX, centerY, size);
                    break;
                case 'triangle':
                    drawTriangle(centerX, centerY, size);
                    break;
                case 'circle':
                    drawCircle(centerX, centerY, size);
                    break;
                case 'rectangle':
                    drawRectangle(centerX, centerY, size);
                    break;
                case 'hexagon':
                    drawHexagon(centerX, centerY, size);
                    break;
                case 'diamond':
                    drawDiamond(centerX, centerY, size);
                    break;
                case 'pentagon':
                    drawPentagon(centerX, centerY, size);
                    break;
                case 'star':
                    drawStar(centerX, centerY, size);
                    break;
                case 'ellipse':
                    drawEllipse(centerX, centerY, size);
                    break;
                case 'trapezoid':
                    drawTrapezoid(centerX, centerY, size);
                    break;
                case 'heart':
                    drawHeart(centerX, centerY, size);
                    break;
                case 'irregular':
                    drawIrregular(centerX, centerY, size);
                    break;
            }
        }

        function drawGrid(centerX, centerY) {
            gameState.ctx.strokeStyle = 'rgba(0, 0, 0, 0.1)';
            gameState.ctx.lineWidth = 1;
            
            // æ°´å¹³ç·š
            for (let i = -200; i <= 200; i += 20) {
                gameState.ctx.beginPath();
                gameState.ctx.moveTo(centerX - 200, centerY + i);
                gameState.ctx.lineTo(centerX + 200, centerY + i);
                gameState.ctx.stroke();
            }
            
            // å‚ç›´ç·š
            for (let i = -200; i <= 200; i += 20) {
                gameState.ctx.beginPath();
                gameState.ctx.moveTo(centerX + i, centerY - 200);
                gameState.ctx.lineTo(centerX + i, centerY + 200);
                gameState.ctx.stroke();
            }
        }

        function drawSquare(x, y, size) {
            gameState.ctx.fillRect(x - size/2, y - size/2, size, size);
            gameState.ctx.strokeRect(x - size/2, y - size/2, size, size);
        }

        function drawTriangle(x, y, size) {
            gameState.ctx.beginPath();
            gameState.ctx.moveTo(x, y - size/2);
            gameState.ctx.lineTo(x - size/2, y + size/2);
            gameState.ctx.lineTo(x + size/2, y + size/2);
            gameState.ctx.closePath();
            gameState.ctx.fill();
            gameState.ctx.stroke();
        }

        function drawCircle(x, y, size) {
            gameState.ctx.beginPath();
            gameState.ctx.arc(x, y, size/2, 0, 2 * Math.PI);
            gameState.ctx.fill();
            gameState.ctx.stroke();
        }

        function drawRectangle(x, y, size) {
            const width = size * 1.5;
            const height = size;
            gameState.ctx.fillRect(x - width/2, y - height/2, width, height);
            gameState.ctx.strokeRect(x - width/2, y - height/2, width, height);
        }

        function drawHexagon(x, y, size) {
            gameState.ctx.beginPath();
            for (let i = 0; i < 6; i++) {
                const angle = (i / 6) * 2 * Math.PI;
                const pointX = x + Math.cos(angle) * size/2;
                const pointY = y + Math.sin(angle) * size/2;
                if (i === 0) {
                    gameState.ctx.moveTo(pointX, pointY);
                } else {
                    gameState.ctx.lineTo(pointX, pointY);
                }
            }
            gameState.ctx.closePath();
            gameState.ctx.fill();
            gameState.ctx.stroke();
        }

        function drawDiamond(x, y, size) {
            gameState.ctx.beginPath();
            gameState.ctx.moveTo(x, y - size/2);
            gameState.ctx.lineTo(x + size/3, y);
            gameState.ctx.lineTo(x, y + size/2);
            gameState.ctx.lineTo(x - size/3, y);
            gameState.ctx.closePath();
            gameState.ctx.fill();
            gameState.ctx.stroke();
        }

        function drawPentagon(x, y, size) {
            gameState.ctx.beginPath();
            for (let i = 0; i < 5; i++) {
                const angle = (i / 5) * 2 * Math.PI - Math.PI/2;
                const pointX = x + Math.cos(angle) * size/2;
                const pointY = y + Math.sin(angle) * size/2;
                if (i === 0) {
                    gameState.ctx.moveTo(pointX, pointY);
                } else {
                    gameState.ctx.lineTo(pointX, pointY);
                }
            }
            gameState.ctx.closePath();
            gameState.ctx.fill();
            gameState.ctx.stroke();
        }

        function drawStar(x, y, size) {
            gameState.ctx.beginPath();
            for (let i = 0; i < 10; i++) {
                const angle = (i / 10) * 2 * Math.PI - Math.PI/2;
                const radius = (i % 2 === 0) ? size/2 : size/4;
                const pointX = x + Math.cos(angle) * radius;
                const pointY = y + Math.sin(angle) * radius;
                if (i === 0) {
                    gameState.ctx.moveTo(pointX, pointY);
                } else {
                    gameState.ctx.lineTo(pointX, pointY);
                }
            }
            gameState.ctx.closePath();
            gameState.ctx.fill();
            gameState.ctx.stroke();
        }

        function drawEllipse(x, y, size) {
            gameState.ctx.beginPath();
            gameState.ctx.ellipse(x, y, size/2, size/3, 0, 0, 2 * Math.PI);
            gameState.ctx.fill();
            gameState.ctx.stroke();
        }

        function drawTrapezoid(x, y, size) {
            gameState.ctx.beginPath();
            gameState.ctx.moveTo(x - size/3, y - size/2);
            gameState.ctx.lineTo(x + size/3, y - size/2);
            gameState.ctx.lineTo(x + size/2, y + size/2);
            gameState.ctx.lineTo(x - size/2, y + size/2);
            gameState.ctx.closePath();
            gameState.ctx.fill();
            gameState.ctx.stroke();
        }

        function drawHeart(x, y, size) {
            gameState.ctx.beginPath();
            // ãƒãƒ¼ãƒˆã®ä¸Šéƒ¨ï¼ˆå·¦ï¼‰
            gameState.ctx.arc(x - size/4, y - size/4, size/4, 0, Math.PI, true);
            // ãƒãƒ¼ãƒˆã®ä¸Šéƒ¨ï¼ˆå³ï¼‰
            gameState.ctx.arc(x + size/4, y - size/4, size/4, 0, Math.PI, true);
            // ãƒãƒ¼ãƒˆã®ä¸‹éƒ¨
            gameState.ctx.lineTo(x, y + size/2);
            gameState.ctx.closePath();
            gameState.ctx.fill();
            gameState.ctx.stroke();
        }

        function drawIrregular(x, y, size) {
            // ä¸è¦å‰‡ãªå›³å½¢
            gameState.ctx.beginPath();
            gameState.ctx.moveTo(x - size/2, y - size/3);
            gameState.ctx.lineTo(x - size/4, y - size/2);
            gameState.ctx.lineTo(x + size/3, y - size/4);
            gameState.ctx.lineTo(x + size/2, y + size/4);
            gameState.ctx.lineTo(x + size/4, y + size/2);
            gameState.ctx.lineTo(x - size/3, y + size/3);
            gameState.ctx.closePath();
            gameState.ctx.fill();
            gameState.ctx.stroke();
        }

        function drawSymmetryAxis(axisType) {
            const centerX = gameState.canvas.width / 2;
            const centerY = gameState.canvas.height / 2;
            
            gameState.ctx.strokeStyle = '#f44336';
            gameState.ctx.lineWidth = 2;
            gameState.ctx.setLineDash([5, 5]);
            
            switch(axisType) {
                case 'vertical':
                    gameState.ctx.beginPath();
                    gameState.ctx.moveTo(centerX, centerY - 150);
                    gameState.ctx.lineTo(centerX, centerY + 150);
                    gameState.ctx.stroke();
                    break;
                case 'horizontal':
                    gameState.ctx.beginPath();
                    gameState.ctx.moveTo(centerX - 150, centerY);
                    gameState.ctx.lineTo(centerX + 150, centerY);
                    gameState.ctx.stroke();
                    break;
                case 'diagonal1':
                    gameState.ctx.beginPath();
                    gameState.ctx.moveTo(centerX - 150, centerY - 150);
                    gameState.ctx.lineTo(centerX + 150, centerY + 150);
                    gameState.ctx.stroke();
                    break;
                case 'diagonal2':
                    gameState.ctx.beginPath();
                    gameState.ctx.moveTo(centerX - 150, centerY + 150);
                    gameState.ctx.lineTo(centerX + 150, centerY - 150);
                    gameState.ctx.stroke();
                    break;
                case 'center':
                    // ç‚¹å¯¾ç§°ã®ä¸­å¿ƒç‚¹
                    gameState.ctx.fillStyle = '#f44336';
                    gameState.ctx.beginPath();
                    gameState.ctx.arc(centerX, centerY, 8, 0, 2 * Math.PI);
                    gameState.ctx.fill();
                    break;
            }
            
            gameState.ctx.setLineDash([]);
        }

        function showAllAxes() {
            // å…¨ã¦ã®å¯¾ç§°è»¸ã‚’è¡¨ç¤º
            gameState.currentFigure.axes.forEach(axis => {
                drawSymmetryAxis(axis);
            });
        }

        function completeSymmetricFigure() {
            // å›³å½¢ã®å¯¾ç§°æ€§ã‚’åˆ©ç”¨ã—ã¦å®Œæˆã•ã›ã‚‹ï¼ˆç°¡æ˜“ç‰ˆï¼‰
            drawSymmetryFigure();
            showAllAxes();
        }

        function clearDrawing() {
            drawSymmetryFigure();
        }

        function showIncorrectFeedback() {
            const canvas = gameState.canvas;
            canvas.style.border = '2px solid #f44336';
            setTimeout(() => {
                canvas.style.border = '2px solid #fff';
            }, 500);
        }

        function checkSymmetryDiscovery() {
            const discoveryRate = (gameState.discoveredAxes.length / gameState.currentFigure.axes.length) * 100;
            
            let message = `âš–ï¸ å¯¾ç§°æ€§ç™ºè¦‹ãƒã‚§ãƒƒã‚¯\\n\\n`;
            message += `å›³å½¢: ${gameState.currentFigure.name}\\n`;
            message += `ç™ºè¦‹è»¸: ${gameState.discoveredAxes.length}/${gameState.currentFigure.axes.length}\\n`;
            message += `ç™ºè¦‹ç‡: ${discoveryRate.toFixed(1)}%\\n\\n`;
            
            if (discoveryRate >= 85) {
                message += 'ğŸ† å„ªç§€ãªç™ºè¦‹ã§ã™ï¼';
                gameState.discoveredCount++;
                gameState.score += 100;
            } else if (discoveryRate >= 60) {
                message += 'ğŸ‘ è‰¯ã„ç™ºè¦‹ã§ã™ï¼';
                gameState.discoveredCount++;
                gameState.score += 50;
            } else {
                message += 'ğŸ“š ã‚‚ã†å°‘ã—è¦³å¯Ÿã—ã¦ã¿ã¾ã—ã‚‡ã†ã€‚';
            }
            
            alert(message);
            
            gameState.currentShape++;
            setTimeout(() => {
                generateNewFigure();
                updateDisplay();
            }, 1000);
        }

        function showSymmetryGuide() {
            const guides = [
                'ğŸ“ å›³å½¢ã‚’ç¸¦ãƒ»æ¨ªãƒ»æ–œã‚ã«åˆ†å‰²ã—ã¦è¦‹ã¦ã¿ã¾ã—ã‚‡ã†',
                'âš–ï¸ å·¦å³ã€ä¸Šä¸‹ãŒåŒã˜å½¢ã‹ãƒã‚§ãƒƒã‚¯ã—ã¦ãã ã•ã„',
                'ğŸ”„ å›³å½¢ã‚’180åº¦å›è»¢ã•ã›ã¦ã‚‚åŒã˜ã‹ã‚‚é‡è¦ã§ã™',
                'âœ¨ ç¾ã—ã„å›³å½¢ã«ã¯å¿…ãšå¯¾ç§°æ€§ãŒã‚ã‚Šã¾ã™',
                'ğŸ¯ è¤‡æ•°ã®å¯¾ç§°è»¸ã‚’æŒã¤å›³å½¢ã‚‚ã‚ã‚Šã¾ã™'
            ];
            
            const randomGuide = guides[Math.floor(Math.random() * guides.length)];
            alert(`å¯¾ç§°æ€§ã®ã‚³ãƒ„:\\n${randomGuide}`);
        }

        function showSymmetryHint() {
            const hint = gameState.currentFigure.axes[0];
            const hints = {
                'vertical': 'ç¸¦ã«æŠ˜ã‚ŠãŸãŸã‚“ã§ã¿ã¦ãã ã•ã„',
                'horizontal': 'æ¨ªã«æŠ˜ã‚ŠãŸãŸã‚“ã§ã¿ã¦ãã ã•ã„',
                'diagonal1': 'å·¦ä¸Šã‹ã‚‰å³ä¸‹ã®æ–œã‚ã«æŠ˜ã£ã¦ã¿ã¦ãã ã•ã„',
                'diagonal2': 'å³ä¸Šã‹ã‚‰å·¦ä¸‹ã®æ–œã‚ã«æŠ˜ã£ã¦ã¿ã¦ãã ã•ã„',
                'center': 'å›³å½¢ã®ä¸­å¿ƒç‚¹ã§å›è»¢ã•ã›ã¦ã¿ã¦ãã ã•ã„',
                'rotational': 'å›³å½¢ã‚’å›è»¢ã•ã›ã¦ã¿ã¦ãã ã•ã„',
                'multiple': 'è¤‡æ•°ã®å¯¾ç§°è»¸ãŒã‚ã‚Šã¾ã™',
                'none': 'ã“ã®å›³å½¢ã¯å¯¾ç§°ã§ã¯ã‚ã‚Šã¾ã›ã‚“'
            };
            
            alert(`ğŸ’¡ ãƒ’ãƒ³ãƒˆ: ${hints[hint] || 'ã‚ˆãè¦³å¯Ÿã—ã¦ãã ã•ã„'}`);
        }

        function resetSymmetry() {
            if (confirm('ç¾åœ¨ã®åˆ†æã‚’ãƒªã‚»ãƒƒãƒˆã—ã¾ã™ã‹ï¼Ÿé€²è¡ŒçŠ¶æ³ãŒå¤±ã‚ã‚Œã¾ã™ã€‚')) {
                gameState.discoveredAxes = [];
                
                // ãƒœã‚¿ãƒ³ã®çŠ¶æ…‹ã‚’ãƒªã‚»ãƒƒãƒˆ
                document.querySelectorAll('.axis-btn').forEach(btn => {
                    btn.classList.remove('active');
                });
                document.querySelectorAll('.tool-btn').forEach(btn => {
                    btn.classList.remove('active');
                });
                
                updateFigureDisplay();
                drawSymmetryFigure();
            }
        }

        function newSymmetryChallenge() {
            if (confirm('æ–°ã—ã„å›³å½¢ã‚’è¡¨ç¤ºã—ã¾ã™ã‹ï¼Ÿç¾åœ¨ã®é€²è¡ŒçŠ¶æ³ãŒå¤±ã‚ã‚Œã¾ã™ã€‚')) {
                generateNewFigure();
                updateDisplay();
            }
        }

        function updateDisplay() {
            document.getElementById('currentShape').textContent = Math.min(gameState.currentShape, gameState.totalShapes);
            document.getElementById('discoveredCount').textContent = gameState.discoveredCount;
            document.getElementById('score').textContent = gameState.score;
            
            const discoveryRate = gameState.currentShape > 1 ? 
                ((gameState.discoveredCount / (gameState.currentShape - 1)) * 100).toFixed(1) : 0;
            document.getElementById('discoveryRate').textContent = `${discoveryRate}%`;
            
            const progress = ((gameState.currentShape - 1) / gameState.totalShapes) * 100;
            document.getElementById('progressFill').style.width = `${progress}%`;
            
            // ã‚²ãƒ¼ãƒ çµ‚äº†ãƒã‚§ãƒƒã‚¯
            if (gameState.currentShape > gameState.totalShapes) {
                setTimeout(endGame, 1000);
            }
        }

        function endGame() {
            const discoveryRate = ((gameState.discoveredCount / gameState.totalShapes) * 100).toFixed(1);
            const passed = discoveryRate >= 85;
            
            let message = `ğŸŠ å¯¾ç§°æ€§ã‚²ãƒ¼ãƒ å®Œäº†ï¼\\n\\n`;
            message += `ç™ºè¦‹å›³å½¢: ${gameState.discoveredCount} / ${gameState.totalShapes}\\n`;
            message += `ç™ºè¦‹ç‡: ${discoveryRate}%\\n`;
            message += `æœ€çµ‚ã‚¹ã‚³ã‚¢: ${gameState.score}ç‚¹\\n\\n`;
            
            if (passed) {
                message += `ğŸ† ã‚¯ãƒªã‚¢é”æˆï¼\\nå„ªç§€ãªå¹¾ä½•å­¦çš„ç¾çš„æ„Ÿè¦šã§ã™ï¼`;
            } else {
                message += `ğŸ“š ã‚‚ã†å°‘ã—é ‘å¼µã‚Šã¾ã—ã‚‡ã†ã€‚\\n85%ä»¥ä¸Šã®ç™ºè¦‹ç‡ã‚’ç›®æŒ‡ã—ã¦ãã ã•ã„ã€‚`;
            }
            
            alert(message);
            
            if (confirm('ã‚‚ã†ä¸€åº¦ãƒ—ãƒ¬ã‚¤ã—ã¾ã™ã‹ï¼Ÿ')) {
                initializeGame();
            }
        }

        function goBack() {
            window.location.href = '../index.html';
        }

        // ã‚²ãƒ¼ãƒ åˆæœŸåŒ–
        initializeGame();
    </script>
</body>
</html>